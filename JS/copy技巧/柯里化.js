/* 
    ?什么时柯里化（curry）
    在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的基数。
    举例来说，
        一个接收3个参数的普通函数，在进行柯里化后，颗粒化版本的函数接收一个参数并返回接收下一个参数的函数，该函数但会一个接收第三个参数的函数。
        最后一个函数在接收第三个参数后，将之前接收到的三个参数应用于普通函数中，并返回最终结果。
    而对于JS语言来说，通常说的柯里化函数的概念，与数学和计算机科学中的柯里化的概念并不完全一样。
    在数学和计算机科学中的柯里化函数，一次只能传递一个参数；
    而JS实际应用中的柯里化函数，可以传递一个或多个参数。
    对于已经柯里化后的函数_fn函数来说，当接收的参数数量与原函数的形参数量相同时，执行原函数；
    当接收的参数的数量小于原函数的形参数量时，返回一个函数用于接收剩余的参数，直至接收的参数数量与形参数量一致，执行原函数。
    ?柯里化的用处：
    柯里化实际把简单的问题复杂化了，但是复杂化的同时，在使用函数时拥有了更加多的自由度。
    而这里对于函数参数的自由处理，正式柯里化的核心所在。柯里化本质上是降低通用性，提高适用性。
    ?如何封装柯里化工具函数
    接收一部分参数，返回一个函数接收剩余的参数，接收足够用，执行原函数、
    当柯里化函数接收到足够参数后，就会执行原函数，那么如何达到足够的参数呢？
    有两种思路：
        1.通过函数的length属性，获取函数的形参个数，形参的个数就是所需的参数个数
        2.在调用柯里化工具函数时，手动指定所需的参数个数
    将上述两点结合一下，实现一个简单的curry函数：
*/
/**
 * 将函数柯里化
 * @params fn 待柯里化的原函数
 * @params len 所需的参数个数，默认为原函数的形参个数
 */
function curry(fn, len = fn.length) {
  return _curry.call(this, fn, len);
}
/**
 * 中转函数
 * @params fn 待柯里化的原函数
 * @params len 所需要的参数个数
 * @params args 已接收的参数列表
 */
function _curry(fn, len, ...args) {
  return function (...params) {
    let _args = [...args, ...params];
    if (_args.length >= len) {
      return fn.apply(this, _args); //参数全了，调用fn函数执行
    } else {
      return _curry.call(this, fn, len, ..._args); //参数不全，再次调用_curry向其内补充参数
    }
  };
}
let _fn = curry(function (a, b, c, d, e) {
  console.log(a, b, c, d, e, 'end');
});
_fn(1, 2, 3, 4, 5); // print: 1,2,3,4,5
_fn(1)(2)(3, 4, 5); // print: 1,2,3,4,5
_fn(1, 2)(3, 4)(5); // print: 1,2,3,4,5
_fn(1)(2)(3)(4)(5); // print: 1,2,3,4,5
