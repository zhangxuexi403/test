// 动态规划Dynamic Programming
// 是一种分阶段求解策略问题的数学思想。它不止用于编程领域，也应用于管理学、经济学、生物学。
// ?动态规划包括三个重要概念：状态转移方程，最优子结构，边界
// 不同路径
// K站中专内最便宜的航班
// 青蛙跳台阶1-2步骤的10个台阶
// 暂且不管从0到8级台阶的过程，也不管从0到9级台阶的过程。想要到10级台阶，最后一步必然是从8级或9级开始。
// 引申出一个新的问题：如果一直0到9级台阶的走法有X种，0到8级台阶的走法有Y种，那么0到10级台阶的走法有多少种？
// 10级台阶的走法可以根据最后一步的不同分成两部分
// 第一部分的最后一步是从9级到10级，这部分的走法数量和9级台阶的走法数量是相等的，也就是X。
// 第二部分的最后一步就是从8级到10级，这部分的走法的数量和8级台阶的走法数量是相等的，也就是Y。这两部分相加，总的走法数量是X+Y。
// 从0到10级台阶的走法 = 0到9级的走法数量+0到8级的走法数量
// 为了表达，将10级台阶的走法数量简化为F(10)=F(9)+F(8),如何计算F(9)和F(8)呢？
// 利用刚才的思路推断出F(9)=F(8)+F(7), F(8)=F(7)+F(6)
// 正在将一个复杂的问题分解u但进行简化，逐步简化成简单的思想，这就是动态规划的思想。
// 当只有1级台阶和2级台阶的时候，有几种走法呢？显然分别是1和2.由此可以归纳出如下的公式：
// F(1)=1; F(2)=2; F(n)=F(n-1)+F(n-2) (n>=3)
// ?刚才分析出的F(10)=F(9)+F(8)，因此F(9)和F(8)是F(10)的 【最优子结构】
// ?当只有1级台阶或者2级台阶时，我们看了一直接得出结果，无需继续简化。我们称F(1)和F(2)是问题的【边界】。如果一个问题没有边界，将永远无法得到有限的结果。
// ?公式本身是状态转移方程

// *不同路径Ⅱ,矩阵左上到右下
// F(m*n)=F((m-1)*n)+F(m*(n-1))
// export default (arr, m, n) => {
//   let dp = (m, n) => {
//     //   m=2.n=2
//     if (m === 2 && n === 2) {
//       return arr[1][1] === 1 || arr[1][0] + arr[0][1] === 2 ? 0 : arr[1][0] === 1 || arr[0][1] === 1 ? 1 : 2;
//     } else if (m < 2 || n < 2) {
//       if (m < 2) {
//         // 单行有1就返回0，没有1就返回1
//         return arr[m - 1].includes(1) ? 0 : 1;
//       } else {
//         // 单列钟不能有障碍物（1）有它返回0，没有就返回1
//         for (let i = 0; i < m; i++) {
//           if (arr[i][0] === 1) {
//             return 0;
//           } else {
//             return 1;
//           }
//         }
//       }
//     } else {
//       return dp(m - 1, n) + dp(m, n - 1);
//     }
//   };
//   return dp(m, n);
// };
// *K站中转内最便宜的航班
// src起始站，dst目的地站，经过k个中转站
// F(src,dst,k) = Min(F(src,dst-1,k-1) + F(dst-1,dst,1))
// export default (src, dst, k) => {
//   let fights = [
//     [0, 1, 100],
//     [1, 2, 100],
//     [0, 2, 500]
//   ];
//   let cheap = (src, dst, k) => {
//     // 找到dst的前一站
//     let prev = fights.filter(item => item[1] === dst);
//     let min = Math.min.apply(
//       null,
//       prev.map(item => {
//         //   dst往前找，找到了起始城市
//         if (item[0] === src && k > -1) {
//           return item[2];
//         } else if (k === 0 && item[0] !== src) {
//           return Number.MAX_SAFE_INTEGER;
//         } else {
//           return item[2] + cheap(src, item[0], k - 1);
//         }
//       })
//     );
//     return min;
//   };
//   return cheap(src, dst, k) || -1;
// };
